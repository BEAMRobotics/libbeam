# beam_mapping

This module contains classes for mapping

## Poses

**Goal/Objectives:**
* To contain all pose information needed to build a map including: poses
(position + orientation), timestamps, frame information, original bag file from
where the data was first recorded, and a date associated with when the poses
were generated
* The object can be built incrementally by adding new poses (e.g., when running
slam), or it can be generated by reading a pose file. This has been built to be
extendable to any type of pose file. For now, we have a method for loading our
own JSON file format as well as a PLY format that is used by the Kaarta Stencil
product. For pose file formats, see the examples in the testing folder.
* Poses can also be built by reading an odometry topic from a ros bag
* We also have a method for writing to these formats when the object is built
incrementally.
* All member variables are public to make it more user friendly for slam and
map building modules.

## Map Builder

**Goal/Objectives:**
* To have a method for building a lidar map given calibrations, poses, and lidar
scans (from a bag).
* This allows the slam to be separated from the map building process. The
benefits of separating these are so that the user can tweak the mapping settings
(including amount of scans to use, filtering, loop closure) without having to
rerun the slam.
* This is also useful when using an external localization module allowing us to
still create a map with our data. For example, we can use the Kaarta Stencil,
a Vicon Systems, or simulation ground truth to generate the poses and then build
a map with those poses.

**Useability:**
* See config file examples in test data
* This has been designed to work with any number of lidars, as long as you have
the lidars in the calibration tree
* Filtering: there are 3 times at which you can apply filters:
    * input_filters: filters are applied to the raw scans
    * intermediate_filters: individual scans are aggregated together into
    submaps of size equal to the "intermediary_map_size" parameter and then the
    filter is applied to that intermediate map. This is useful if you want to
    use noise removal filters that only work with a minimum point cloud density
    * output_filters: these filters are applied once at the end of the mapping
    once the maps have been generated
* Types of filters: There are currently 4 types of filters that can be applied
    * DROR: Dynamic Radius Outlier Removal filter, see
    https://ieeexplore.ieee.org/abstract/document/8575761
    * ROR: Radius Outlier Removal filter, see
    http://docs.pointclouds.org/trunk/classpcl_1_1_radius_outlier_removal.html
    * VOXEL: voxel grid downsampling filter, see
    http://docs.pointclouds.org/1.8.1/classpcl_1_1_voxel_grid.html
    * CROPBOX: This is our own custom implementation of the crop box filter
    which allows you to remove point inside or outside a user defined box, see
    https://github.com/BEAMRobotics/libbeam/blob/master/beam_filtering/include/beam_filtering/CropBox.h

**Using main executable:**
* There is a main executable that you can use to build your maps.
* Arguments:
      * 1. Full path to the config file (e.g., /path/to/config.json)
      * 2. topic name if using a poses from an odometry topic in the bag
      (e.g., /odometry_filtered). This topic MUST be of type nav_msgs/Odometry
